<schedule><conference><title>PyConES 2015</title><subtitle /><venue>Universidad Politécnica de Valencia</venue><start>2015-11-20</start><end>2015-11-22</end><days>3</days><timeslot_duration>00:40</timeslot_duration></conference><day date="2015-11-20" index="1"><room name="Paraninfo" /><room name="1G-0.5 (Avanzado)" /><room name="1G-0.6 (Científico)" /><room name="1G-0.4 (Básico)" /><room name="Hall"><event id="35"><date>2015-11-20T17:30:00+0100</date><start>17:30</start><duration>00:30</duration><room>Hall</room><title>Coffee Break</title></event></room><room name="Aula 1"><event id="33"><date>2015-11-20T15:00:00+0100</date><start>15:00</start><duration>02:30</duration><room>Aula 1</room><title>Usando contenedores para Big Data</title><description>En la actualidad existe una variedad bastante grande de contenedores de datos para almacenar grandes cantidades de datos en Python, tanto en memoria como en disco.  En mi taller pasaremos revista a unos cuantos de los más útiles, empezando por los más básicos y generales (listas, diccionarios, NumPy/ndarray, pandas/DataFrames) a los más especializados (RDBMS, PyTables/Table/HDF5,  bcolz/carray/ctable).  Durante el camino se darán pistas de cuando usar unos u otros dependiendo del caso de uso.</description><abstract>Motivación----------------Actualmente en el mundo Python existen dos grandes conjuntos de contenedores que se usan típicamente en tratamiento de Big Data: ndarrays de NumPy y DataFrames de Pandas.  La gran ventaja de estos contenedores es que vienen acompañados por unas librerías muy completas de funciones que trabajan de manera nativa sobre ellos, haciéndolos extremadamente útiles en general.Más allá de NumPy y Pandas------------------------------------------Sin embargo, no existe el contenedor (o estructura) universal de datos, y el hecho de que el tratamiento de Big Data requiera un uso extremo de todos los recursos que un ordenador (o grupo de ordenadores)  hace que tanto los ndarrays como los DataFrames sean inaceptablemente ineficientes en muchas ocasiones.  En otras, una combinación de ndarray y DataFrames con contendores nativos de Python puede que sea la combinación adecuada.  Y finalmente, existen contenedores especializados (bases de datos relacionales, PyTables/HDF5, bcolz) que ofrecen mejores prestaciones para problemas particulares.Haciendo 'profiling' de nuestras aplicaciones----------------------------------------------------------------Cuando se trabaja con aplicaciones que requieren un uso tan extremo de los recursos de los ordenadores, hacer profiling de las aplicaciones para saber donde se usan los recursos, se convierte en una tarea fundamental.  En mi taller se ejercitará esta faceta fundamental para saber el consumos de CPU y memoria cuando se trabaja con los distintos contenedores de datos, dando una visión mejor de las bondades y limitaciones de cada uno de ellos.</abstract><persons><person>Francesc Alted</person></persons></event><event id="36"><date>2015-11-20T18:00:00+0100</date><start>18:00</start><duration>02:30</duration><room>Aula 1</room><title>Introducción a visualizaciones interactivas con Bokeh</title><description>Bokeh ( http://bokeh.pydata.org/en/latest/ ) es una librería de visualización de datos con una interfaz concisa y elegante que permite la construcción de gráficos preparados para la web y con interactividad out-of-the-box y sencilla.Diseña avanzados dashboards en Python para un navegador web sin escribir ni una línea de código de Javascript (pero si quieres puedes ;P)Interactividad cliente-side, cliente-servidor, streaming, big data... Simplemente Bokeh! :)</description><abstract>Programa1. Introducción a Bokeh (15m)    "Pero a mi me gusta X, ¿merece la pena aprender Bokeh?"    Motivación y ventajas frente a alternativas.    Futuro de la plataforma2. Conceptos clave y arquitectura (30m)    Abstract rendenring y ¿"Big Visualziations"?    Models y BokehJS3. Ejemplos sencillos Python (1h)    Usaremos rbokeh http://hafen.github.io/rbokeh/ y bokehhttp://bokeh.pydata.org/en/latest/    (Si queréis seguir los ejemplos traedlo en el portátil)4. ¡Oh se mueve! Interactividad y Streaming de datos (1h)    ¿Cómo insertar widgets?    Callbacks (lado del cliente)    Tools (Hover, Select, Crosshair)5. ¿Y ahora qué? (~5m)    Características avanzadas: streaming y abstract rendering    Referencias y bibliografía</abstract><persons><person>Alejandro Vidal</person></persons></event></room><room name="Aula 2"><event id="34"><date>2015-11-20T15:00:00+0100</date><start>15:00</start><duration>02:30</duration><room>Aula 2</room><title>Python en gvSIG, el Sistema de Información Geográfica Libre</title><description>Taller orientado a los que quieran iniciarse en el uso de python para desarrollar funcionalidades en gvSIG, un Sistema de Información Geográfica libre.La idea seria dividir el taller en tres bloques:1.-Una introducción, de nivel básico. Veremos como manipular datos espaciales y generar nuevas capas a partir de algunas ya existentes.2.-Un ejemplo de manipulación de mapas, de nivel intermedio. 3.-Un ejemplo de creación  de interfaces de usuario desde scripting, de un nivel avanzado.</description><abstract>La idea seria dividir el taller en tres bloques:1.-Una introducción, de nivel básico. Pensado para usuarios con pocos conocimientos sobre programación y python. Veremos como manipular datos espaciales y generar nuevas capas a partir de algunas ya existentes.2.- Un ejemplo de manipulación de mapas (documento mapa), de nivel intermedio. Veremos algunos trucos para personalizar nuestros mapas con un poco de scripting…        Ajustando la extensión del mapa a visualizar        Personalizando rótulos de este.        Cargando imágenes personalizadas.    Además veremos algunos trucos para poder descubrir de que operaciones disponemos sobre los distintos componentes u objetos a los que tenemos acceso, así como donde podemos consultar información sobre algunos de ellos.3.-Un ejemplo de creación de interfaces de usuario desde scripting, de un nivel avanzado. Veremos como crear formularios con una herramienta externa, propia de Java, que nos permitirá crear interfaces de usuario fácilmente con una alta integración con el resto de gvSIG  y como usarlos desde un script…        Crear formularios de forma sencilla        Cargarlos desde un script y acceder a sus componentes        Asociar operaciones a los botones de nuestros formularios...Continuaremos con lo que habíamos creado en el punto anterior para dotarlo de interfaz gráfica y acabar disponiendo de una herramienta que nos permita personalizar nuestros mapas.</abstract><persons><person>Joaquín del Cerro</person></persons></event><event id="37"><date>2015-11-20T18:00:00+0100</date><start>18:00</start><duration>02:30</duration><room>Aula 2</room><title>Simplifica tu vida con sistemas complejos y algoritmos genéticos</title><description>¿Qué es un algoritmo genético? ¿Qué es un sistema complejo? ¿Cómo puedo usarlos para resolver problemas complicados? En este taller abordaremos estos temas y aprenderemos a diseñar y usar algoritmos de este tipo con Python.</description><abstract>#Simplifica tu vida con sistemas complejos y algoritmos genéticos.¿Qué es un algoritmo genético? ¿Qué es un sistema complejo? ¿Cómo puedo usarlos para resolver problemas complicados? En este taller abordaremos estos temas y aprenderemos a diseñar y usar algoritmos de este tipo con Python.##Parte I: Presentación y descripción (20-30 minutos)Tiempo | Actividad-- | --2 - 5 min | Presentación de los ponentes y del tema. 5 min | ¿Qué es un algoritmo genético?1 - 3 min | Ejemplo5 min | ¿Qué es un sistema complejo? 1 - 3 min | Ejemplo5 min | El dilema exploración - explotación, feedback positivo y negativo1 - 3 min | Ejemplo##Intermedio: ¡Carrera de coches! (10 minutos)Minijuego para demostrar la potencia de este tipo de algoritmos. Los participantes y un algoritmo genético tienen 5 minutos para diseñar un bólido ¿quién será más rápido?##Parte II: Presentación de la actividad (20 - 30 minutos)Tiempo | Actividad-- | --10 min | Presentación de las herramientas y bibliotecas que se van a utilizar.10 - 15 min | Proposición de problemas para resolver con A.G. y/o S.C.0 - 5 min | Dudas y preguntas##Parte III: Desarrollo de la actividad (60 - 90 minutos)Los participantes en el taller dispondrán de tiempo para intentar resolver los problemas propuestos que deseen.##Parte IV: AnálisisTiempo | Actividad-- | --5 min | Recopilación de resultados10 min | Discusión y comparación de los resultados, gráficas0 - 10 min | Dudas y preguntas</abstract><persons><person>Carlos Dorado</person><person>Siro Moreno</person></persons></event></room><room name="Aula 3"><event id="32"><date>2015-11-20T15:00:00+0100</date><start>15:00</start><duration>02:30</duration><room>Aula 3</room><title>Single-Page Applications con Django y Backbone</title><description>En este taller llevaremos a cabo un caso práctico. La construcción de una Single-Page Application usando Backbone como herramienta front-end. Ahora que cada día aparece una docena de frameworks de JavaScript, suena sensato buscar algo de estabilidad en un framework de trayectoria ya constatada, como es Backbone. Por otra parte, tener un framework como Django en el back-end proporciona robustez, facilidad de uso y muchísima extensibilidad -gracias al increíble ecosistema pythónico-.</description><abstract>En este taller, llevaremos a cabo el desarrollo completo de una single-page application, usando tecnologías como **Django**, **unittest**, **tastypie** (o **Django Rest Framework**), **PostgreSQL**, **Backbone.js**, **Bootstrap**, etc.Partiendo de cero, llegaremos a tener una aplicación totalmente funcional. Por un lado, el código front-end, escrito en JavaScript, se encargará de la presentación de los datos y su manejo en el cliente. Por otro lado, el framework Django apoyado sobre una base de datos PostgreSQL se encargará de la persistencia de los modelos y sus interrelaciones. Además, implementará una API REST que permitirá la comunicación con el navegador.Si el tiempo nos lo permite, implementaremos además un buscador basado en **ElasticSearch**.Resultará sorprendente para los asistentes ver la inmediatez del desarrollo sin dejar de lado buenas prácticas de programación (testing, pep8, uso de linters, etc).### RequisitosPortátil con conexión a internet y el siguiente software instalado: * Python 2.6+ * Django 1.6+ * pip * virtualenv (se recomienda virtualenvwrapper) * Algún navegador web :)</abstract><persons><person>Miguel Sánchez Rodríguez</person><person>Miguel González Nieto</person></persons></event><event id="38"><date>2015-11-20T18:00:00+0100</date><start>18:00</start><duration>02:30</duration><room>Aula 3</room><title>Better async code with Python 3</title><description>Learn async web development hands-on by using asyncio event loop in combination with subgenerator delegation syntax (yield from), creating beautiful concurrent code without writing a single callback.</description><abstract /><persons><person>Anton Caceres</person></persons></event></room></day><day date="2015-11-21" index="2"><room name="Paraninfo"><event id="1"><date>2015-11-21T09:00:00+0100</date><start>09:00</start><duration>01:00</duration><room>Paraninfo</room><title>Charla Plenaria</title></event></room><room name="1G-0.5 (Avanzado)"><event id="2"><date>2015-11-21T10:00:00+0100</date><start>10:00</start><duration>00:40</duration><room>1G-0.5 (Avanzado)</room><title>DSLs: Can't parse that!♫</title><description>Se introducirá brevemente qué es un DSL, tipos y cuándo resultan interesantes, mostrando algunos ejemplos. Para pasar a describir un caso práctico, creando un DSL real desde cero para procesamiento de textos, viendo como parsearlo, interpretarlo y resolver un problema de una forma distinta a la que estamos acostumbrados, dándole una nueva perspectiva.</description><abstract>Se introducirá brevemente qué es un DSL, tipos: externos o internos y en qué problemas de dominio resultan interesantes, mostrando algunos ejemplos reales de ambos tipos. A continuación se describirá un caso práctico, creando un DSL real desde cero para procesamiento de textos. Introduciendo el lenguaje con ejemplos reales de uso, para luego descomponerlo en elementos y ver cómo generar una gramática que lo describa.Después se presentarán algunas de las herramientas disponibles para generar parsers de una gramática y resolver cómo parsear nuestro DSL en Python.Finalmente se interpretarán las instrucciones del DSL, resolviendo el procesamiento de textos de una forma distinta a la que estamos acostumbrados, dándole una nueva perspectiva.</abstract><persons><person>Miguel Araujo</person></persons></event><event id="7"><date>2015-11-21T10:40:00+0100</date><start>10:40</start><duration>00:40</duration><room>1G-0.5 (Avanzado)</room><title>Escalando una web con python</title><description>Construir una web y soportar su crecimiento en tráfico tiene su intríngulis. Unaarquitectura sencilla se irá complicando poco a poco a medida que crece enfuncionalidad y en número de usuarios. Veremos un proyecto simplón, como podríaempezar cualquier web que hiciésemos nosotros mismos y la iremos evolucionando yampliando, descubriendo y solucionando los problemas típicos que surgen a lahora de hacer escalar una web.</description><abstract>Construir una web y soportar su crecimiento en tráfico tiene su intríngulis. Unaarquitectura sencilla se irá complicando poco a poco a medida que crece enfuncionalidad y en número de usuarios. Veremos un proyecto simplón, como podríaempezar cualquier web que hiciésemos nosotros mismos y la iremos evolucionando yampliando, descubriendo y solucionando los problemas típicos que surgen a lahora de hacer escalar una web.Veremos por encima los diversos problemas con los que nos enfrentamos al hacer crecer una web. Si el tiempo nos lo permite, pasaremos por encima y hablaremos de los siguientes temas:* Modelo de procesos: pesados, threads, micro-threads, green-threads, corrutinas...* Modelos de ejecución de proyectos en python.* I/O asíncrona.* Comunicación en tiempo real: long polling, SSE, websockets...* Escalado vertical y horizontal.* Cachés (memcached, redis, varnish, nginx).* Esclavos de lectura y/o clusters escritura-escritura en la BD.</abstract><persons><person>Jose Ignacio Galarza</person></persons></event><event id="10"><date>2015-11-21T11:50:00+0100</date><start>11:50</start><duration>00:40</duration><room>1G-0.5 (Avanzado)</room><title>Syntactic Macros in Python</title><description>Syntactic Macros enable the programmer to manipulate the shape of the program before executing it allowing to extend the features of the language. Inspired by macropy, in this talk I explain how to get syntactic macros working with Python 3 at import time giving a couple of interesting examples.</description><abstract /><persons><person>Salvador de la Puente González</person></persons></event><event id="13"><date>2015-11-21T12:30:00+0100</date><start>12:30</start><duration>00:40</duration><room>1G-0.5 (Avanzado)</room><title>"Embedding" de Python en otras aplicaciones</title><description>Es común ampliar las funcionalidades de Python mediante extensiones y módulos externos. Tecnologías como Cython y todo el entorno numpy son posibles mediante la integración de código C compilado en un programa Python en ejecución. Pero es muy interesante, también, el poder incluir un intérprete Python en un programa independiente para poder ampliar sus funcionalidades escribiendo código Python en vez programando en C.</description><abstract>Estudiaremos los mecanismos de integración de un intérprete Python en código C y lo aplicaremos para ampliar sus funcionalidades utilizando módulos escritos en nuestro lenguaje favorito.Ampliaremos programas como el servidor web Apache (mod_python y mod_wsgi), el servidor de correo Postfix o el servidor IMAP4 Dovecot. Puede ser que incluso podamos meterle mano a Mozilla Firefox, aunque eso no lo puedo prometer aún.Lo que sí es seguro es que Python tiene su lugar en todas partes.dddddddddd d d d d d d d d  dd d d d d d d dd d d d </abstract><persons><person>Jesús Cea</person></persons></event><event id="15"><date>2015-11-21T13:10:00+0100</date><start>13:10</start><duration>00:40</duration><room>1G-0.5 (Avanzado)</room><title>Python tips, tricks and dark magic</title><description>Python tiene una gran cantidad de funcionalidades ocultas, pero a la vez a la vista de todos. Esta charla descubrir algunas de ellas explicando como funcionan, cuando tiene sentido usarlas y dando casos prácticos de como usarlas con ejemplos de código que las usan.</description><abstract>Python tiene una gran cantidad de funcionalidades ocultas, pero a la vez a la vista de todos. Esta charla descubre algunas de ellas explicando como funcionan, cuando tiene sentido usarlas y dando casos prácticos de como usarlas con ejemplos de código que las usan.Entre otras cosas se tratarán: - Excepciones: ¿Qué tipos de excepciones hay? ¿Cómo funciona exactamente el sistema try/except/finally/else? - Packing/unpacking: ¿Qué es? ¿Cuando y cómo usarlo? - Idioms: Funcionalidades del lenguaje poco conocidas en python. Especialmente útil para programadores que empezaron programando en otros lenguajes. - Diccionarios: Algunas funcionalidades poco conocidas de esta útil estructura de datos. - Listas: Ejemplos básicos del funcionamiento de las listas.Dada la temática de la presentación, está diseñada para ser útil tanto para principiantes como para usuarios avanzados. </abstract><persons><person>Jordi Soucheiron Estruch</person></persons></event><event id="21"><date>2015-11-21T15:00:00+0100</date><start>15:00</start><duration>00:40</duration><room>1G-0.5 (Avanzado)</room><title>SQJobs: Sencillo sistema de tareas en segundo plano</title><description>Muchos son los sistemas de tareas en segundo plano en Python, como por ejemplo Celery.Sí, en Ticketea hemos creado uno más, pero intentando hacerlo diferente.Simple Queue Jobs intenta ser una cola de tareas sencilla y fiable que simplemente funcione y cuyo código no intimide a aquellos que busquen familiarizarse con él.</description><abstract /><persons><person>Federico Mon</person></persons></event><event id="24"><date>2015-11-21T15:40:00+0100</date><start>15:40</start><duration>00:40</duration><room>1G-0.5 (Avanzado)</room><title>Learning by Trolling</title><description>Explicación de diferentes conceptos y caracteristicas de python a traves de formas de trollear a compañeros. (monkeypatching, cache de enteros, excepciones...)</description><abstract>Explicación de diferentes conceptos y caracteristicas de python a traves de formas de trollear a compañeros. (monkeypatching, cache de enteros, excepciones...)La idea es que haya un recorrido por diferentes trolleos que se pueden hacer a los compañeros, mientras explico los conceptos asociados a estos, de modo que a la vez que pasamos un buen rato, aprendemos como y porque funcionan algunas cosas en python.La audiencia debería, al menos, tener algo de experiencia programando en python para poder seguir facilmente los ejemplos y las explicaciones.</abstract><persons><person>Jesús Espino</person></persons></event><event id="27"><date>2015-11-21T16:50:00+0100</date><start>16:50</start><duration>00:40</duration><room>1G-0.5 (Avanzado)</room><title>Django request-response: Un viaje de ida y vuelta</title><description>Todos sabemos que cuando tenemos una aplicación hecha en Django ejecutándose en un servidor, y le llega una petición, tarde o temprano nuestro código se ejecutará y le devolveremos una respuesta al usuario, pero... ¿Qué ocurre antes y después de la ejecución de nuestro código?, ¿qué tareas hace Django por nosotros sin ni siquiera ser conscientes de ello?, ¿es posible modificar este comportamiento?, y lo más importante:  ¿cómo?</description><abstract>¿Sabemos realmente cómo procesa Django las requests?, ¿qué componentes de Django intervienen en este proceso?, ¿cómo se crea una response válida?. Sigamos el viaje que da una request por los internals de Django hasta convertirse en response para conocer los componentes que intervienen en este proceso y ver que tareas realiza para nosotros sin ser conscientes siquiera de ello. ¿Cómo funcionan los middlewares?, ¿cómo es posible que nos permitan modificar tanto las requests como las responses?Conocer los internals nos dará una visión global de qué es lo que ocurre dentro de Django para servir nuestro código, y seremos conscientes de la complejidad de la que nos abstrae</abstract><persons><person>Imanol Cea</person></persons></event><event id="30"><date>2015-11-21T17:30:00+0100</date><start>17:30</start><duration>00:40</duration><room>1G-0.5 (Avanzado)</room><title>Integrando Apache Storm como servidor de aplicaciones Python</title><description>Apache Storm es un sistema de procesamiento en tiempo real diseñado para escalar horizontalmente de forma simple y rápida con garantía de procesamiento. Está basado en Java, no obstante, permite utilizar multiples lenguajes de programación, incluido Python, de forma que no necesites usar Java para nada. En esta charla explicaré el caso de uso de Server Density para el procesamiento de "payloads" para la monitorización de servidores.</description><abstract>Apache Storm es un sistema de procesamiento en tiempo real diseñado para escalar horizontalmente de forma simple y rápida con garantía de procesamiento. Está basado en Java, no obstante, permite utilizar multiples lenguajes de programación, incluido Python, de forma que no necesites usar Java para nada. En esta charla explicaré el caso de uso de Server Density para el procesamiento de `payloads` para la monitorización de servidores, como integrar un productor de datos para Apache Kafka como vía de entrada de información en Apache Storm y la forma de paralelizar todo el proceso para poder ejecutar un procesado completo de cada `payload` en el menor tiempo posible.Como parte de la charla se expondrán diversos problemas que se nos presentaron por la forma que tiene de funcionar Apache Storm y la forma con la que los resolvimos, así como mejoras que estamos estudiando para implantar.</abstract><persons><person>Carlos Perelló Marín</person></persons></event></room><room name="1G-0.6 (Científico)"><event id="3"><date>2015-11-21T10:00:00+0100</date><start>10:00</start><duration>00:40</duration><room>1G-0.6 (Científico)</room><title>Navigating the Data Science Python Ecosystem</title><description>Do you feel lost with all the libraries being developed in the Python ecosystem for Data Science? Have you heard of scikit-learn, theano, dask, xray, blaze, gensim, bokeh, pymc3, numba, jupyter..., but don't know where to start or what each library is for? Do you ask yourself, what is Data Science anyway? Deep learning vs Machine learning? Then, this talk is for you! We'll learn what Data Science is, as well as, existing libraries, functionality and applications in the ecosystem.</description><abstract /><persons><person>Christine Doig</person></persons></event><event id="5"><date>2015-11-21T10:40:00+0100</date><start>10:40</start><duration>00:40</duration><room>1G-0.6 (Científico)</room><title>Autosubmit: investigando el clima con Python</title><description>¿Cómo investigar aquello con lo que no puedes experimentar? Utilizando modelos. El problema es que simular algo tan complejo como el clima requiere programas que utilizan cientos de procesadores y generan teras de resultados. En esta charla te contaremos como [Autosubmit](https://pypi.python.org/pypi/autosubmit) es capaz de manejar estos gigantescos experimentos para que los climatólogos puedan dedicarse a la ciencia sin problemas</description><abstract>Investigar el clima es complicado. Sólo disponemos de un planeta para estudiar y, como vivimos en él, no parece muy buena idea utilizarlo para experimentar. ¿Qué opción nos queda? Utilizar modelosEstos modelos, sin embargo, son tan complejos que requieren un poder de computación que sólo se encuentra en los grandes supercomputadores. Entonces, ¿cómo un grupo de investigación que no puede costearse uno de ellos puede enfrentarse a este problema? ¡Contratando informáticos y desarrollando [Autosubmit](https://pypi.python.org/pypi/autosubmit)!Autosubmit es la herramienta encargada de que la ejecución de estos modelos se lleve a cabo sin contratiempos. Es decir, que cada parte se ejecute cuando y donde toca, que se reintente si falla y que cada experimento tenga su propio identificador y no interfiera nunca con los demás. Incluso debe ser capaz de que cuando se detecta algún problema con una parte del experimento sólo sea necesario repetir el mínimo imprescindible de trabajo aunque hayan pasado años dese la ejecución. Así que si quieres saber como hemos resuelto estos problemas (y alguno más) ven a vernos y aprenderás algo de este mundo donde un ordenador del Top500 a veces no es suficiente</abstract><persons><person>Javier Vegas Regidor</person></persons></event><event id="9"><date>2015-11-21T11:50:00+0100</date><start>11:50</start><duration>00:40</duration><room>1G-0.6 (Científico)</room><title>SocialLearning: encontrando materiales formativos de manera colaborativa</title><description>Social learning es una plataforma de gestión documental orientada al descubrimiento y clasificación de recursos formativos (videos, documentos, páginas web, etc) a partir de búsquedas en redes sociales de forma masiva y automatizada.Es un proyecto libre (https://github.com/alabarga/SocialLearning) desarrollado en Python y utiliza librerías como Django, REST framework, NTLTK, Celery/Redis, etc.</description><abstract>El objetivo principal del este proyecto consistía en desarrollar una plataforma de gestión documental orientada al descubrimiento y clasificación de recursos formativos (videos, documentos, páginas web, etc) a partir de búsquedas en redes sociales de forma masiva y automatizada, una tarea que podía dividirse en tres tareas:**Recuperación de información relevante**, es decir, extraer de manera automática aquellos documentos que puedan resultar interesantes para el usuario a partir de una consulta realizada por éste a una serie de fuentes. Tanto la consulta como las fuentes se pueden actualizar automáticamente en función de una serie de reglas definidas y de los valores de relevancia e interés definidos para las fuentes. **Categorización de documentos**, consiste en asignar a cada documento una o varias categorías temáticas de entre un conjunto de categorías preestablecido.**Clustering**, consiste en la generación automática de grupos de documentos relacionados, por ejemplo, documentos que traten un mismo tema o asunto. A diferencia de lo que ocurre en la categorización, en los procesos de clustering no existe un conjunto de categorías preestablecido, sino que el propio algoritmo a utilizar debe generar automáticamente esas categorías, contribuyendo de esta forma a generar un nuevo conocimiento.El proyecto se enmarca dentro del concepto más amplio de aprendizaje social o **Social Learning** y este es el nombre que le hemos dado al módulo que desarrolla estos conceptos dentro de la plataforma.</abstract><persons><person>Alberto Labarga</person></persons></event><event id="12"><date>2015-11-21T12:30:00+0100</date><start>12:30</start><duration>00:40</duration><room>1G-0.6 (Científico)</room><title>Introducción a visualizaciones interactivas con Bokeh</title><description>Bokeh ( http://bokeh.pydata.org/en/latest/ ) es una librería de visualización de datos con una interfaz concisa y elegante que permite la construcción de gráficos preparados para la web y con interactividad out-of-the-box y sencilla.Diseña avanzados dashboards en Python para un navegador web sin escribir ni una línea de código de Javascript (pero si quieres puedes ;P)Interactividad cliente-side, cliente-servidor, streaming, big data... Simplemente Bokeh! :)</description><abstract>Programa1. Introducción a Bokeh (5m)    Motivación y ventajas frente a alternativas.    Models y BokehJS2. Ejemplos sencillos Python (10h)3. ¡Oh se mueve! Interactividad y Streaming de datos (15m)    Callbacks (lado del cliente)    Tools (Hover, Select, Crosshair)Todo lo veremos mediante ejemplos en directo. Y en la parte final monto una wifi ad-hoc para que vean alguna de las características del servidor de Bokeh y como se puede interactuar entre usuarios.Tendré  en mi github los ejemplos por si se quiere seguir, pero es una charla demostrativa más que práctica.</abstract><persons><person>Alejandro Vidal</person></persons></event><event id="16"><date>2015-11-21T13:10:00+0100</date><start>13:10</start><duration>00:40</duration><room>1G-0.6 (Científico)</room><title>Python en la industria: el problema de optimización (matemática) </title><description>La optimización matemática es utilizada en la industria para la resolución de diferentes problemas, que van desde la selección óptima de equipos y recursos a la gestión logística de una empresa. En esta charla, estudiantes de ingeniería química de la Universidad de Alicante realizarán una introducción visual a conceptos de optimización, presentarán Pyomo y mostrarán la resolución de casos de estudio de diferentes industrias mediante este lenguaje de modelado algebraico desarrollado en Python.</description><abstract>**Breve descripción**La optimización o programación matemática mediante lenguajes de modelado algebraico ---comúnmente [GAMS](http://www.gams.com/), [AMPL](http://ampl.com/) y [AIMMS](http://www.aimms.com/)--- es utilizada en la industria para la resolución de diferentes problemas que van desde la selección óptima de equipos y recursos a la gestión logística de una empresa. [Pyomo](http://www.pyomo.org/) es un paquete de software de código abierto ---licenciado bajo BSD por [Sandia National Laboratories](http://www.sandia.gov/), USA--- desarrollado en Python, y que soporta un conjunto diverso de capacidades de optimización para la formulación y el análisis de modelos de optimización. En particular, Pyomo permite el modelado de problemas tipo [LP](https://en.wikipedia.org/wiki/Linear_programming), [QP](https://en.wikipedia.org/wiki/Quadratic_programming), [NP](https://en.wikipedia.org/wiki/Nonlinear_programming), MILP, MINLP, MISP entre otros y se comunica con los principales solvers comerciales, gratuitos y/o libres, así como la plataforma ofrecida por [NEOS](http://www.neos-server.org/neos/) server. La resolución mediante métodos de optimización ---comunes en un ámbito de investigación científica--- son a menudo desconocidos en la industria o bien delegados por falta de tiempo y/o recursos. Por tanto, su resolución acaba siendo mediante métodos menos eficientes que resultan en formas de trabajo con condiciones sustancialmente mejorables. Por este motivo, en esta charla, estudiantes de ingeniería química de la Universidad de Alicante realizarán una introducción visual a conceptos de optimización, presentarán Pyomo y mostrarán la resolución de casos de estudio de diferentes industrias mediante este lenguaje de modelado algebraico desarrollado en Python.**Resumen detallado**La optimización de procesos industriales ha experimentado un crecimiento considerable durante los últimos años. Las industrias modernas apuestan por ella para mejorar la producción, reducir los costes, disminuir el impacto ambiental e incrementar la seguridad. En este sentido, es sensata la introducción y formación de los nuevos ingenieros en esta rama de la ciencia. Resulta curioso pensar que en el ámbito de las ciencias de la computación, la optimización suele hacer referencia a la reducción en el tiempo de ejecución del programa. Pero la optimización matemática (también conocida como investigación de operaciones o programación matemática) no tiene nada que ver con este problema y, en muchos casos, la formación que se recibe en las universidades no pasa de explicar el algoritmo SIMPLEX para la resolución de problemas lineales con variables continuas. Un problema de optimización consiste, a grandes rasgos, en maximizar o minimizar una función real eligiendo sistemáticamente valores de entrada (tomados de un conjunto permitido) y calculando el valor de la función. Este problema se vuelve interesante cuando aparecen restricciones (lineales y no lineales) y variables enteras (para modelar la toma de decisiones discretas). Dos de los lenguajes de modelado comerciales más utilizados para resolver este tipo de problemas matemáticos son GAMS y AMPL. En Python existen varias bibliotecas que permiten resolver el mismo tipo de problemas como son [CVXOpt](http://cvxopt.org/), [CVXPy](http://www.cvxpy.org/en/latest/), [PulP](https://pythonhosted.org/PuLP/), [OpenOpt](http://openopt.org/Welcome), o Pyomo. Este último, Pyomo.org, resulta interesante ya que:*  Permite la modelización matemática en Python tipo AMPL/GAMS*  Se comunica directamente los principales solvers como GLPK, Gurobi, CPLEX, CBC y PICO*  Es open source (licencia BSD) y está desarrollado por Sandia National Laboratories, USA.*  Pyomo (antiguamente conocido como Coopr) es 100% gratuito, maduro y bien documentado*  Soporta Python 3 y su instalación es sencilla*  Se comunica con NEOS server (plataforma web que da acceso a solvers comerciales de forma gratuita)*  Se adapta al modelado de problemas de todo tipo al estar desarrollado en PythonPor lo tanto, Pyomo proporciona una capacidad que se asocia comúnmente con lenguajes de modelado algebraico comerciales como AMPL, AIMMS y GAMS, pero los objetos de modelado de Pyomo están incrustados dentro de Python, un lenguaje de programación de alto nivel con todas las funciones con un rico conjunto bibliotecas científicas. Respecto a sus capacidades como lenguaje de modelado algebraico, Pyomo es compatible con una amplia gama de tipos de problemas de optimización, incluyendo entre otros:*  Programación lineal*  Programación cuadrática*  Programación no lineal*  Programación lineal entera mixta*  Programación cuadrática mixta entero*  Programación lineal entera mixta*  Programación estocástica entera mixta*  Programación disyuntiva generalizada*  Ecuaciones algebraicas diferencialesLa charla queda estructurada en tres partes bien diferenciadas:Introducción a la optimización/programación matemática (10 min): Se realizará una introducción visual a los conceptos de optimización con restricciones (Linear Programing, Non-Linear Programing, ILP, MIP, MINLP). Introducción a la sintaxis de Pyomo y breves notas para la instalación (10 min): donde se verán ejemplos sencillos de optimización con Pyomo y se explicará de manera breve la manera de instalarlo. Serie de ejemplos de problemas de optimización en ingeniería (10 min): tomando especial atención a ejemplos resueltos de problemas de optimización reales en la industria e ingeniería química.**¿Quiénes somos?**[CAChemE](http://cacheme.org/) es una asociación sin ánimo de lucro formada por ingenieros químicos (profesionales, docentes y estudiantes) que pretende estimular las posibilidades de software en la ingeniería de procesos químicos. Nuestro objetivo es promover las ventajas de las nuevas herramientas de software libre disponibles y fomentar su uso tanto en la industria como en la universidad. La sede central de CAChemE se encuentra en el [Instituto Universitario de Ingeniería de Procesos Químicos](http://iipq.ua.es/) de la [Universidad de Alicante](http://www.ua.es/).</abstract><persons><person>Daniel Domene</person><person>Carlos Planelles</person></persons></event><event id="22"><date>2015-11-21T15:00:00+0100</date><start>15:00</start><duration>00:40</duration><room>1G-0.6 (Científico)</room><title>Know your models - Statsmodels!</title><description>Scikit-learn has become the best known and most used package to perform it-just-works Machine Learning in Python. But what happens when you want to look into what is going on within your models to inspect and improve them? In this talk we will present the not-so-well-known packages statsmodels and patsy that can help us to achieve a better undestanding of your models and your data.</description><abstract>Scikit-learn has become the best known and most used package to perform it-just-works Machine Learning in Python. But what happens when you want to look into what is going on within your models to inspect and improve them? In this talk we will present the not-so-well-known packages statsmodels and patsy that can help us to achieve a better undestanding of your models and your data. This talk, addressed to beginners, will illustrate some common problems while working with scikit-learn and possible approaches to face them with the use of these libraries.</abstract><persons><person>Israel Saeta Pérez</person><person>Miquel Camprodon</person></persons></event><event id="19"><date>2015-11-21T15:40:00+0100</date><start>15:40</start><duration>00:40</duration><room>1G-0.6 (Científico)</room><title>Data structures beyond dicts and lists</title><description>As a python backend engineer you might end up using (or abusing) lot's of dicts and lists, iterating on them. This is mainly due their easy usage and might be also  because libraries like pandas or numpy fall down in the domain of data science.We will see a real example where an old implementation is refactored to have better use of pandas and constantly comparing the performance increase.</description><abstract /><persons><person>Sergi Sorribas</person></persons></event><event id="28"><date>2015-11-21T16:50:00+0100</date><start>16:50</start><duration>00:40</duration><room>1G-0.6 (Científico)</room><title>Seguridad y criptografía en Python</title><description>La charla tendrá como objetivo introducir la criptografía y la seguridad desde el punto de vista del desarrollador, mostrando maneras de cifrar la información con scripts de Python y la información más sensible en aplicaciones web usando Django,comentando la principales vulnerabilidades que podemos encontrar en un sitio web(SQL injection,XSS, CSRF) y cómo Django nos puede ayudar a evitar ataques que se aprovechen de estas vulnerabilidades.</description><abstract>###Entre los puntos a tratar se pueden destacar:1. Introducir los conceptos clave utilizados dentro del mundo de la criptografía.2. Introducción a algunas librerías de criptografía como pyCrypto o cryptographyVoy a presentar la seguridad en Python, mostrando algunas librerías que permiten el encriptado y desencriptado de los datos como Pycrypto o Cryptography, comparando los principales sistemas de cifrado como AES, RSA, PBKDF2.3. Mejores prácticas y técnicas más avanzadasPara utilizar correctamente las funciones criptográficas, comentaré técnicas más avanzadas como Key Stretching para la generación de claves seguras para evitar ataques por diccionario o por fuerza bruta.Mostraré otras técnicas más avanzadas como la esteganografía que permiten ocultar información en archivos (imágenes, documentos, programas) con algunas librerías de Python como Stepic o Stegano.4. Desarrollo seguro y buenas prácticas en aplicaciones web con Django.Con respecto al desarrollo seguro de aplicaciones desarrolladas con Django, podemos encontrar dentro del proyecto OWASP, un conjunto de buenas prácticas para detectar cómo Django nos puede ayudar a evitar ataques que se aprovechen de estas vulnerabilidades.En este punto comentaré la principales vulnerabilidades que podemos encontrar en un sitio web(SQL injection,XSS, CSRF) y cómo Django nos puede ayudar a evitar ataques que se aprovechen de estas vulnerabilidades</abstract><persons><person>José Manuel Ortega</person></persons></event><event id="29"><date>2015-11-21T17:30:00+0100</date><start>17:30</start><duration>00:40</duration><room>1G-0.6 (Científico)</room><title>PhaseSpace un programa para analizar sistemas dinámicos</title><description>PhaseSpace es un programa diseñado para analizar sistemas dinámicos de un modo sencillo. Para ello dibuja el mapa de fases de dicho sistema y además permite dibujar los puntos críticos y las curvas de pendiente 0 e infinito, tanto explícitas como implícitas, así como el campo vectorial y las soluciones del sistema que queremos estudiar. También permite seleccionar el método numérico para realizar los cálculos y cambiar los ejes y el paso de integración.</description><abstract>&lt;h1&gt;Introducción: Sistemas dinámicos&lt;/h1&gt;&lt;p&gt;Desde los orígenes de la ciencia, el hombre ha tratado de entender y explicar su entorno, pero se ha encontrado con un mundo cambiante, donde todo está en movimiento, y se ha propuesto comprender elcómo y el porqué de esos movimientos. Una forma de explicar este comportamiento es a través de las Ecuaciones Diferenciales Ordinarias (EDO’s), y de sistemas compuestos por estas. La teoría de los sistemas dinámicos intenta entender procesos en movimiento, es decir cambios o variaciones de un objeto con respecto al tiempo. Se entiende por un sistema dinámico al sistema de ecuaciones diferenciales ordinarias expresados como:&lt;/p&gt;x'=f(x,y)y'=g(x,y)&lt;p&gt;Los sistemas no lineales (1.1) no son resolubles analíticamente en su gran mayoría. Por eso se tratan de dibujar las proyecciones de sus soluciones, llamadas órbitas o trayectorias, sobre el plano xy. A este plano se le llama plano de fases y al conjunto de trayectorias retrato o mapa de fases del sistema.&lt;/p&gt;&lt;p&gt;Para hacer su dibujo aproximado debemos hallar sus puntos críticos o de equilibrio (proyecciones de sus soluciones constantes) y analizar de que tipo son. Estos puntos son los x* tales que f(x*)=g(x*)=0 .&lt;/p&gt;&lt;p&gt;También es útil encontrar las rectas de pendiente cero e infinito dadas, respectivamente, por g=0 y por f=0. &lt;/p&gt;&lt;p&gt;Y dibujar también su campo vectorial (f,g), campo tangente a sus órbitas.&lt;/p&gt;dx/dy=f(x,y)/g(x,y)&lt;p&gt;Un aspecto importante de los sistemas lineales es que el comportamiento de sus soluciones cerca de un punto de equilibrio nos dice el comportamiento de las soluciones en todo el plano. Sin embargo, para los sistemas no lineales, la aproximación lineal no nos da información de lo que sucede lejos del punto, para obtener dicha información de un modo sencillo es necesario dibujar el mapa de fases del sistema y a estudiar su estabilidad mediante métodos numéricos. Eso permite obtener rápidamente resultados fiables en muchos casos. &lt;/p&gt;&lt;p&gt;Al recurrir a métodos numéricos no solo estamos limitados a estudiar la estabilidad en el entorno de los puntos críticos si no que podremos dibujar las trayectorias del mapa de fases en todo el plano, lo que eslargo y complicado de analizar sin ordenador.&lt;/p&gt;&lt;p&gt;De este modo pasamos de un estudio puramente teórico de las EDOs a un estudio experimental ya que podemos ver las distintas trayectorias de fases al interactuar con el programa y en vista a la forma de dichastrayectorias podemos trazar otras trayectorias y ver los puntos críticos, por lo que podemos analizar un sistema de EDOs sin tener ninguna noción de su comportamiento a priori y sin tener que hacer ningún análisis teórico preliminar.&lt;/p&gt;&lt;h1&gt;PhaseSpace&lt;/h1&gt;&lt;h3&gt;Sobre PhaseSpace&lt;/h3&gt;&lt;p&gt;Actualmente no existe una herramienta sencilla y de fácil manejo que permita dibujar y analizar sistemas dinámicos. El uso de Mathematica o Maple para hacerlo resulta engorroso y poco intuitivo y requiere conocer el lenguaje que utilizan.&lt;/p&gt;&lt;p&gt;PhaseSpace es un programa diseñado para analizar sistemas dinámicos de un modo sencillo. Para ello dibuja el mapa de fases de dicho sistema y además permite dibujar los puntos críticos y las curvas de pendiente 0 e infinito, tanto explícitas como implícitas, así como el campo vectorial y las soluciones del sistema que queremos estudiar. También permite seleccionar el método numérico para realizar los cálculos y cambiar los ejes y el paso de integración.&lt;/p&gt;&lt;p&gt;PhaseSpace ha sido programado en Python usando las bibliotecas Tkinter, numpy y matplotlib&lt;/p&gt;&lt;p&gt;Los métodos numéricos implementados por ahora son el método de Heun, y el de Runge-Kutta de orden 4&lt;/p&gt;&lt;h3&gt;Limitaciones de PhaseSpace&lt;/h3&gt;&lt;p&gt;**Estabilidad:**existen sistemas de ecuaciones diferenciales, llamados sistemas rígidos, para los cuales los dos métodos numericos no funcionan ya que ambos son métodos explícitos. La solución consistiría en implementar uno o dos métodos numéricos implícitos, comopor ejemplo el euler implícito o alguna de sus variantes.&lt;/p&gt;&lt;p&gt;**Problemas mal planteados:** PhaseSpace no puede representar sistemas de EDOs que tengan regiones no definidas.&lt;/p&gt;</abstract><persons><person>Anton Ferré Pujol</person></persons></event></room><room name="1G-0.4 (Básico)"><event id="4"><date>2015-11-21T10:00:00+0100</date><start>10:00</start><duration>00:40</duration><room>1G-0.4 (Básico)</room><title>#!/usr/bin/python (Python para Sysadmins)</title><description>En esta charla se presenta la experiencia de un Sysadmin utilizando Python como lenguaje de scripting avanzado.Se introducirán funcionalidades básicas del lenguajes así como una serie de módulos y trucos que facilitarán la vida de cualquier administrador de sistemas que quiera ir más allá de bash.Esta es la charla que me hubiera gustado escuchar cuando empecé a escriptar mis primeras tareas para gestionar servidores y servicios y que me hubiera ahorrado tiempo y facilitado la vida.</description><abstract>#!/usr/bin/python (Python para sysadmins)===================================Usando Python como lenguaje de scripting avanzado-------------------------------------------------------Ya deberías de estar usando *Ansible* para todas las tareas de instalación, configuración de servidores así como deployment de aplicaciones. Pero...*y para todo lo demás*(TM) ¿Qué pasa cuando tienes que *crawlear* y procesar cierta información de la web del ministerio de no sé dónde para ayer? ¿O extraer ciertos datos de un CSV e insertarlo en una base de datos?Esta es una charla totalmente **opinionada** en la que se presentarán qué módulos deberías de utilizar para llevar a cabo ciertas tareas comunes (pasar parámetros por línea de comandos, procesar la salida de otro comando,  listar de ficheros, etc...), así como que funcionalidades básicas/avanzadas(?) de Python te ayudarán a realizarlas con éxito.Aviso--------Esta charla es como una de esas películas *siesteras* de sobremesa: simple, facilona pero... **basada en hechos reales**.Acerca de--------------Después de casi cinco años *rompiendo* servidores en el CERN ahora trabajo en una ex-startup de Barcelona administrando servidores a uno y otro extremo de los cables de fibra submarinos. </abstract><persons><person>Andreu Belmonte Peña</person></persons></event><event id="6"><date>2015-11-21T10:40:00+0100</date><start>10:40</start><duration>00:40</duration><room>1G-0.4 (Básico)</room><title>Click: Como hacer interfaces de comandos con Python</title><description>Click es un paquete de Python que permite la creación rápida y bonita de interfaces de linea de comandos, utilizando pocas lineas de código, de una manera bastante estructurada y componible. Click resuelve las típicas situaciones en las que el programador se ve obligado a hacer un interfaz de comandos y termina por hacerse uno propio.</description><abstract>En numerosos proyectos de software o de administración de sistemas,  llega un momento en que el desarrollador tiene la necesidad de poseer una interfaz de comandos para ejecutar sus tareas rutinarias, o, simplemente, para simplificar su workflow.En ese momento, normalmente uno se termina haciendo esta interfaz de comandos en shell script, porque "para dos cosas que voy a hacer con ello..." y termina complicándose. Comienzas añadiendo parametros, validadores, compartiendo funciones e incluso reescribiendo la herramienta en un lenguaje mas complejo, y vuelta otra vez a empezar el ciclo. Tiempo después, tu interfaz se ha vuelto tan compleja que no sabes cómo gestionarla, adquiere conciencia propia, empieza a entrar en sistemas de defensa de otros paises y se hace llamar a si mismo Skynet. Evidentemente, esto es una parodia de una cosa que nos ha pasado a todos más de una vez. Y justo para eso esta Click, para que en la medida de lo posible, no volvamos a hacernos un CLI a mano.Click es un paquete de python que trata de resolver precisamente esta problemática: necesito un CLI y lo necesito ya, quiero que sea bonito, quiero que sea mantenible y quiero que tenga "--help". De este paquete se podrían resaltar las siguientes características: * Anidación arbitraria de comandos* Generación de ayuda automática* "Lazy loading" de subcomandos en tiempo de ejecuciónCon Click se puede crear desde un simple comando para ejecutar los tests o hacer depliegues, hasta un interfaz tan compleja como es la propia de git, ¡con plugins y todo!</abstract><persons><person>Roberto Majadas Lopez</person></persons></event><event id="11"><date>2015-11-21T11:50:00+0100</date><start>11:50</start><duration>00:40</duration><room>1G-0.4 (Básico)</room><title>let's Twisted again!</title><description>Haz que tus programas sean reactivos a determinados eventos de red. Para ello podemos contar con el framework conocido como Twisted, durante la charla aprenderás lo básico para usarla.Twisted es un motor orientado a eventos de redes y tiene licencia de código libre (MIT).</description><abstract>Aprende a usar Twisted para ello durante la charla se mostrará como funciona Twisted detallando un ejemplo de un programa funcional. Además se explicará el concepto de orientación a eventos que se basa Twisted. Así mismo se comentará sobre qué protocolos de redes se pueden trabajar por estar ya implementados o bien los pasos necesarios sobre como crear tu  propio servico sobre TCP y se hará una demo de su funcionamiento al finalizar la charla.Al acabar la charla podrías ser capaz de crear tus propios programas que empleen éste framework.</abstract><persons><person>Israel D. Aguilar</person></persons></event><event id="14"><date>2015-11-21T12:30:00+0100</date><start>12:30</start><duration>00:40</duration><room>1G-0.4 (Básico)</room><title>La maquinaria de import, ese mágico desconocido</title><description>importar módulos y librerías en python es una de las cosas más mágicas que existen. Básicamente funciona pero no sabemos como ni porque. En la charla se explicará como funciona y porque puede ser útil saber como funciona.</description><abstract /><persons><person>Raúl Cumplido</person></persons></event><event id="17"><date>2015-11-21T13:10:00+0100</date><start>13:10</start><duration>00:40</duration><room>1G-0.4 (Básico)</room><title>Python Funcional</title><description>Implementacion de varios de los elementos que componen la programacion funcional mediante Python.</description><abstract># Resumen #La charla tratará de mostrar como es parte de la **programación funcional** y como podemos aplicarla en Python.Se explorará cómo trabajar con las funciones, utilizándolas como parametrosy resultados (**Funciones de Orden Superior**).Se verá como sustituir bucles y list comprehensions por sus equivalentesen **map, filter y reduce**. Y como estos cubren un espectro mucho mas amplio.Como tercer pilar de la charla esta la **recursividad**, la cual es posible enpython con ciertas limitaciones.# Esquema inicial de la charla ### Conceptos básicos ##- HOF- Efectos colaterales## Reduce, Map, Filter ##- Breve explicacion- Descubre como funcionan reimplementandolos## Recursividad ##- Recursividad en Python- TCO y Trampolining## Buenas practicas derivadas de la PF ### Publico objetivo #Asistentes con curiosidad por la Programacion Funcional.</abstract><persons><person>Guillermo Vayá Pérez</person></persons></event><event id="20"><date>2015-11-21T15:00:00+0100</date><start>15:00</start><duration>00:40</duration><room>1G-0.4 (Básico)</room><title>Objetos mutable e inmutables y errores típicos</title><description>En esta charla veremos varios errores típicos hechos al usar objetos mutables de Python, revisaremos 5 conceptos clave para entender lo que estaba sucediendo en cada caso y, finalmente, la forma de resolver o evitar esos errores.Nivel requerido: Básico / Intermedio. Los asistentes deben saber algunos conceptos de Python como declaración de clases y funciones, la herencia, atributos de clase...</description><abstract>El título alternativo de esta charla podría ser:"Errores típicos cuando se manipulan con objetos mutables e inmutables de Python y no se tiene un entendimiento completo de cómo funcionan ciertas interioridades de Python."En esta charla veremos varios errores típicos hechos al usar objetos mutables de Python, revisaremos 5 conceptos clave para entender lo que estaba sucediendo en cada caso y, finalmente, la forma de resolver o evitar esos errores.Nivel requerido: Básico / Intermedio. Los asistentes deben saber algunos conceptos de Python como declaración de clases y funciones, la herencia, atributos de clase...Esta es una versión revisada de una charla que di en pybcn (meetup de Python de Barcelona).</abstract><persons><person>Pablo Enfedaque</person></persons></event><event id="23"><date>2015-11-21T15:40:00+0100</date><start>15:40</start><duration>00:40</duration><room>1G-0.4 (Básico)</room><title>Revisión de código en Python</title><description>El objetivo de esta charla es dar a conocer los beneficios de la revisión de código, detallando los aspectos prácticos para llevar a cabo esta técnica de manera exitosa en proyectos colaborativos de desarrollo de software escritos en Python.</description><abstract /><persons><person>Cesar Cardenas Desales</person></persons></event><event id="26"><date>2015-11-21T16:50:00+0100</date><start>16:50</start><duration>00:40</duration><room>1G-0.4 (Básico)</room><title>Python descriptors al detalle</title><description>En esta charla repasaremos el protocolo de los descriptores, casos de uso y sus aplicaciones más directas en la librería estándar, como son properties y slots.La audiencia debería tener un conocimiento medio / alto de Python y entender el data model de los objetos de Python (los magic methods).</description><abstract>Un descriptor es un atributo cuyo acceso para lectura, modificación y eliminación ha sido sobreescrito por métodos en el protocolo descriptor.Aunque pueda parecer sencillo, es gracias al protocolo descriptor que el "binding" de métodos de clase y de instancia funciona. Además de proveer casos de uso muy interesantes también tienen varias aplicaciones directas en la libraría estándar; las properties y los slots.En la charla veremos:- Introducción al descriptor protocol; __get__, __set__ y __del__- Ejemplos de caso de uso- Aplicaciones en la librería estándar-- Properties-- SlotsLa audiencia debería tener un conocimiento medio / alto de Python y entender el data model de los objetos de Python (los magic methods).</abstract><persons><person>Pablo Enfedaque</person></persons></event><event id="31"><date>2015-11-21T17:30:00+0100</date><start>17:30</start><duration>00:40</duration><room>1G-0.4 (Básico)</room><title>Extending Python</title><description>Python is a great language, but there are occasions where we need access to lowlevel operations or connect with some database driver written in C or we need toovercome to some speed boottleneck in Python due to some limitation in thelanguage, like NumPy or Scikit-learn do, using extensions.With the FFI(Foreign function interface) we can connect Python with otherlanguages like C, C++ and even Rust or Fortran.</description><abstract>Python is a great language, but there are occasions where we need access to lowlevel operations or connect with some database driver written in C or we need toovercome to some speed boottleneck in Python due to some limitation in thelanguage, like NumPy or Scikit-learn do, using extensions.With the FFI(Foreign function interface) we can connect Python with otherlanguages like C, C++ and even Rust or Fortran.There are some alternatives to achieve this goal, Native Extensions, Ctypes and CFFI.We'll compare this three ways of extending Python and we'll study pros and consof each approach.</abstract><persons><person>Francisco Fernández Castaño</person></persons></event></room><room name="Hall"><event id="8"><date>2015-11-21T11:20:00+0100</date><start>11:20</start><duration>00:30</duration><room>Hall</room><title>Coffee Break</title></event><event id="18"><date>2015-11-21T13:50:00+0100</date><start>13:50</start><duration>01:10</duration><room>Hall</room><title>Comida</title></event><event id="25"><date>2015-11-21T16:20:00+0100</date><start>16:20</start><duration>00:30</duration><room>Hall</room><title>Coffe Break</title></event></room><room name="Aula 1"><event id="67"><date>2015-11-21T18:10:00+0100</date><start>18:10</start><duration>01:00</duration><room>Aula 1</room><title>Lightning Talks</title></event></room><room name="Aula 2" /><room name="Aula 3" /></day><day date="2015-11-22" index="3"><room name="Paraninfo"><event id="66"><date>2015-11-22T16:50:00+0100</date><start>16:50</start><duration>01:00</duration><room>Paraninfo</room><title>Charla Plenaria</title></event></room><room name="1G-0.5 (Avanzado)"><event id="39"><date>2015-11-22T09:20:00+0100</date><start>09:20</start><duration>00:40</duration><room>1G-0.5 (Avanzado)</room><title>Sirviendo 1M de tickets en 50 idiomas y 35 divisas</title><description>El crecimiento exponencial de Ticketbis nos exige una arquitectura que pueda escalar horizontalmente. Teniendo en cuenta que servimos casi 1M de tickets en 50 idiomas y 35 divisas diferentes, la desnormalización de los datos y su correspondiente cacheo eran necesarios. ¿Queréis saber cómo lo hacemos sin un solo hit a la base de datos? Os doy una pista: demonios pythónicos + Redis + Elasticsearch.</description><abstract>**[Ticketbis](http://ticketbis.com)** está presente en más de **40 países** a través de sus casi **50 sites**. La publicación de un ticket para un evento concreto implica una serie de variaciones en los datos en función del site (divisa, fechas de entrega, tipo de ticket, temas legales, etc) que nos obliga a la desnormalización y cacheo de los mismos para garantizar unos tiempos de respuesta razonables.Os contaremos la arquitectura que tenemos montada para hacer frente al alto tráfico que soportamos, y cómo unos **scripts en python** se encargan de abastecer las cachés de **Redis** y el cluster de **Elasticsearch** evitando el acceso a base de datos hasta el momento de la compra.#### Hablaremos de:- Gestión de **colas** en la redis.- **Invalidación** de cachés.- **Indexación** en Elasticsearch.- **Optimizaciones** en python para mejorar los tiempos de respuesta.- **Escalado horizontal** del sistema ante picos de carga para soportar por ejemplo, el *onsale* de los Rolling Stones.- Y alguna cosilla más ;)#### ¿El reto? *Stale tickets*, no ~~queremos~~ podemos venderle el mismo ticket a dos usuarios diferentes ;)</abstract><persons><person>Jose Gargallo</person></persons></event><event id="44"><date>2015-11-22T10:00:00+0100</date><start>10:00</start><duration>00:40</duration><room>1G-0.5 (Avanzado)</room><title>asyncIO: póngase a la cola por favor</title><description>En esta charla veremos como usar python3 con asyncio, websockets y redis paraconstruir un servicio distribuido de colas virtuales con los que controlar deforma ordenada el acceso a un servicio con elevada carga pico.</description><abstract /><persons><person>Miguel Araujo</person><person>Jose Ignacio Galarza</person></persons></event><event id="45"><date>2015-11-22T10:40:00+0100</date><start>10:40</start><duration>00:40</duration><room>1G-0.5 (Avanzado)</room><title>Un python nuevo para ti: decorators</title><description>Python es un lenguaje de programación con muchas funcionalidades interesantes. Sin embargo, existen ciertas features habituales en otros lenguajes de programación que no tienen cabida en este: sobrecarga de métodos, un operador para la composición de funciones, comprobación de tipos...En esta charla veremos cómo podemos conseguir estas funcionalidades utilizando decorators e inspeccionando los objectos que representan a las funciones.</description><abstract>## DecoratorsEn la charla se explicarán en primer lugar qué son los decorators de manera que los asistentes que no estén informados lo entiendan rápidamente para poder seguir la charla.## Objetos que representan a funcionesSe explicará rápidamente para el que no lo sepa que en python las funciones también son objetos. Como todos los objetos, podemos inspeccionar sus propiedades con ````dir````, y nos fijaremos en algunos atributos que nos permiten obtener información de funciones como el número de parámetros que aceptan, el valor de los parámetros por defecto... El módulo ````inspect```` nos ayudará también en esta labor.## Añadiendo funcionalidades a python### Arreglando el paso de parámetros por defectoLa gente que lleve programando en python un tiempo habrá tenido alguna vez  problemas con el paso por defecto de parámetros mutables a sus funciones. Mediante un decorator que inspeccionará los valores por defecto de la función al que se quiera aplicar este, conseguiremos hacer que todo funcione de la forma en que la mayoría de pythonistas creen que debería funcionar.### Sobrecarga de métodosAccediendo al nombre de la función y al número de parámetros que acepta, podremos crear un decorator que permita que se pueda llamar a distintas funciones con el mismo nombre según el número de parámetros que se le aporten al método en cuestión. Esto nos permitirá realizar la sobrecarga de métodos que tan habitualmente encontramos en otros lenguajes.### Comprobación de tiposVeremos también que es posible hacer que las funciones que hagamos en python comprueben los tipos que se le suministren sin ningún tipo de boilerplate. Veremos que podemos combinar este decorator de la comprobación de tipos con el de sobrecarga de métodos para que se llame a distintas funciones según el tipo de los parámetros especificados.### Composición de funcionesEn algunos lenguajes, especialmente en los funcionales, la composición de funciones es una operación habitual. En python sin embargo no disponemos de un operador que nos permita hacer esto. Gracias a un decorador, a un wrapper sobre funciones y a los magic methods de python conseguiremos definir un operador para la composición de funciones.### MetaYa que tenemos unos cuantos decoradores "útiles" podemos encontrar casos de uso. En particular, veremos que la composición de decoradores nos puede permitir hacer cosas interesantes, y para esto utilizaremos nuestro decorador de sobrecarga de funciones sobre el resto de nuestros decoradores para crear decoradores compuestos mucho más potentes.</abstract><persons><person>Braulio Valdivielso</person></persons></event><event id="50"><date>2015-11-22T11:50:00+0100</date><start>11:50</start><duration>00:40</duration><room>1G-0.5 (Avanzado)</room><title>El módulo "tracemalloc"</title><description>El módulo "tracemalloc", añadido a la librería estándar en Python 3.4, permite monitorizar el uso de memoria y nos ayuda a diagnosticar y solucionar "Memory Leaks". Su utilidad es indudable, pero su uso está poco difundido.</description><abstract>Descripción del módulo "tracemalloc", incluído en la librería estándar de Python 3.4. Casos de uso y abuso. Se recorrerá el rango completo, desde los usos evidentes a partir de la documentación a casos complejos que requieren la utilización de varias herramientas. Si da tiempo se analizarán casos reales de "memory leaks"."tracemalloc" es uno de esos módulo poco conocidos que realmente hacen que valga la pena migrar a Python 3. No obstante existe también un "port" de este módulo a versiones anteriores de Python, incluyendo Python 2.7.</abstract><persons><person>Jesús Cea</person></persons></event><event id="52"><date>2015-11-22T12:30:00+0100</date><start>12:30</start><duration>00:40</duration><room>1G-0.5 (Avanzado)</room><title>Comparing Python ORM</title><description>El objetivo de la charla es mostrar algunos de los sistemas ORM que podemos encontrar dentro del ecosistema de Python como Sqlalchemy, Storm, Sqlobject, Django ORM,realizando una comparativa entre ellos,mostrando ventajas y desventajas de cada uno.Algunas de las características a comparar son performance, eficiencia, tratamiento de caché, consultas.Por ultimo, se comentarán las ventajas que aportan estos sistemas para la seguridad de la aplicaciones web con Django.</description><abstract>###Entre los puntos a tratar se pueden destacar:1.  Introducción a ORMEl objetivo de un ORM es abstraernos de la base de datos y del sistema gestor que hay por debajo.Las tablas se mapean en clases ,las filas en instancias de objetos de las clases y las columnas de las tablas como atributos o propiedades en las clases.2. ORM en PythonAdemás proveen un lenguaje de consultas basadas en objetos de Python,de forma que por ejemplo si queremos realizar una consulta sobre una determinada tabla bastaría con ejecutar ejecutar el método select sobre el objeto del cual queremos recuperar información.3. Comparación a nivel de performance,eficiencia,cache.Ventajas y desventajasTambién ofrecen un sistema de caché,de tal forma que si al hacer una consulta los datos ya se encuentran en memoria no sería necesario ir a la BD.4. Seguridad que aportan en aplicaciones webOtra de las ventajas que ofrecen estos sistemas es la seguridad en la medida que ofrecen soluciones a vulnerabilidades como sql injection ,cross site scripting en aplicaciones web con Django, ya que están preparados para construir sentencias preparadas y evitar que un posible atacante utilize técnicas de inyección de parámetros en las consultas.</abstract><persons><person>José Manuel Ortega</person></persons></event><event id="56"><date>2015-11-22T13:10:00+0100</date><start>13:10</start><duration>00:40</duration><room>1G-0.5 (Avanzado)</room><title>Metaprogramación en Python</title><description>Según wikipedia: “La metaprogramación consiste en escribir programas que escriben o manipulan otros programas (o a sí mismos) como datos, o que hacen en tiempo de compilación parte del trabajo que, de otra forma, se haría en tiempo de ejecución. Esto permite al programador ahorrar tiempo en la producción de código.” En esta charla veremos diferentes mecanismos que Python proporciona como: - Decoradores - Metaclasses.</description><abstract /><persons><person>Raúl Cumplido</person></persons></event><event id="60"><date>2015-11-22T15:00:00+0100</date><start>15:00</start><duration>00:40</duration><room>1G-0.5 (Avanzado)</room><title>Hacking the Taiga</title><description>Taiga es una herramienta de gestión ágil de proyectos donde prima ante todo la experiencia de usuario. En esta charla trataré de mostrar cómo puedes desarrollar nuevas funcionalidades para ti, tu organización o comunidad, sin necesidad de modificar el core de Taiga.</description><abstract>Taiga es una herramienta de gestión ágil de proyectos donde prima ante todo la experiencia de usuario; según nuestros usuarios, Taiga es fácil de usar, intuitiva, visualmente atractiva y además los equipos pueden adaptarlo perfectamente a diferentes workflows de trabajo. Las mismas premisas guiaron el diseño de la arquitectura de la aplicación: queríamos que los usuarios y organizaciones que implantasen Taiga disfrutasen de mucha flexibilidad al añadir nuevas funcionalidades, y por eso Taiga es hackeable por diseño. En esta charla trataré de mostrar cómo puedes desarrollar nuevas funcionalidades para ti, tu organización o comunidad, sin necesidad de modificar el core de Taiga.</abstract><persons><person>David Barragán Merino</person></persons></event><event id="63"><date>2015-11-22T15:40:00+0100</date><start>15:40</start><duration>00:40</duration><room>1G-0.5 (Avanzado)</room><title>Amqp from Python, advanced design patterns</title><description>AMQP as standard application layer protocol is widely used to design backends where business logic is spread around different processes using a broker to link them, usually RabbitMQ. AMQP  allows us to use different design patterns than the traditional monolithic backends, where part of your business logic is designed as entities of the AMQP topology. In this talk we will talk about the Python drivers such as Celery, Pika and others, and how they can be used to get the full power of the AMQP.</description><abstract /><persons><person>Pau Freixes, Arnau Orriols</person></persons></event></room><room name="1G-0.6 (Científico)"><event id="40"><date>2015-11-22T09:20:00+0100</date><start>09:20</start><duration>00:40</duration><room>1G-0.6 (Científico)</room><title>Es posible hacer una tesis doctoral en turbulencia con Python</title><description>La simulación numérica directa de flujos turbulentos es una disciplina particularmente exigente en lo que respecta a manejo de datos a gran escala. Las simulaciones que llevamos a cabo en el grupo de investigación guardan del orden de centenares de terabytes de datos, y su proceso suele generar entre dos y tres veces esta cantidad. Después del primer año de tesis doctoral decidí ponerme de conejillo de indias para comprobar si Python es en la práctica tan bueno como se dice en teoría.</description><abstract>Uno de los casos más extremos del Big Data es el proceso de grandes cantidades de datos que generan experimentos y simulaciones. En este caso, del orden de 250TiB han sido machacados y procesados con Python, Numpy, Scipy y Matplotlib. El resultado de un proceso que ha durado cuatro años han sido unas 40 gráficas en Matplotlib. Por el camino se han utilizado desde mi PC a clusters de ordenadores. Las librerías científicas de Python han sido prácticamente la única herramienta que se ha utilizado.Esta charla propone una visión crítica de lo mejor y lo peor de la experiencia desde el punto de vista de alguien que ya conocía otras herramientas como Matlab. Python puede sustituir Matlab, incluso lo mejora abiertamente en muchas facetas. Por otro lado, he visto como ciertos problemas de adaptación han hecho que otros compañeros lo descartaran. Incluso el conflicto entre Python 2 y Python 3.</abstract><persons><person>Guillem Borrell Nogueras</person></persons></event><event id="42"><date>2015-11-22T10:00:00+0100</date><start>10:00</start><duration>00:40</duration><room>1G-0.6 (Científico)</room><title>Thumbor, el servidor de imágenes libre e inteligente</title><description>Thumbor es un servidor de imágenes escrito en python. Es capaz de procesar imágenes bajo demanda e incluye funcionalidad de procesado (con opencv) para adaptar las redimensiones de manera inteligente. En esta charla introduciré su utilización y entresijos con el despliegue. </description><abstract>Thumbor es un servidor de imágenes inteligente escrito en python. Sigue la filosofía [12factor](http://12factor.net/) y nos ayuda a solucionar la problemática típica de los proyectos modernos con sus gráficos, entre otros: múltiples aplicaciones compartiendo media, tamaños variables y necesidad de servir rápido.Thumbor es capaz de recoger, procesar y servir las imágenes bajo demanda e incluye funcionalidad de detección de caras o puntos importantes (con opencv) para adaptar las redimensiones de manera inteligente.En esta charla introduciré su utilización, exponiendo ejemplos prácticos de los casos de uso más habituales y también mostraré como se puede desplegar fácilmente con Docker con una imagen cosecha propia.</abstract><persons><person>Edu Herraiz</person></persons></event><event id="46"><date>2015-11-22T10:40:00+0100</date><start>10:40</start><duration>00:40</duration><room>1G-0.6 (Científico)</room><title>Machine Learning in the Cloud with Python</title><description>La charla mostará cómo introducir el aprendizaje automático en cualquier proyecto usando plataformas de SAAS accesibles via API. En particular, nos centraremos en el caso de los servicios disponibles en BigML. Veremos como acceder a ellos a distintos niveles: usando los bindings para Python y también mediante un DSL en línea de comandos.</description><abstract>La charla mostará cómo introducir el aprendizaje automático en cualquier proyecto usando plataformas de SAAS accesibles via API. En particular, nos centraremos en el caso de los servicios disponibles en BigML. Veremos como acceder a ellos a distintos niveles: usando los bindings para Python y también mediante un DSL en línea de comandos.</abstract><persons><person>Mercè Martin</person></persons></event><event id="51"><date>2015-11-22T11:50:00+0100</date><start>11:50</start><duration>00:40</duration><room>1G-0.6 (Científico)</room><title>Trolling Detection with Scikit-learn and NLTK</title><description>La inmensa mayoría del contenido que se crea diariamente en Internet es desestructurado. Aproximadamente el 90% del mismo es texto. En la era de la web colaborativa, usamos el lenguaje constantemente, por ejemplo, para escribir una crítica de un producto, comentar una foto o escribir un tweet. Esta información es tremendamente valiosa en muchos sentidos. En esta charla veremos algunas de las herramientas que ofrece el ecosistema Python para comprender, estructurar y extraer valor de un texto.</description><abstract>El texto es, con diferencia, la unidad de información más utilizada en Internet y, a la vez, más difícil de procesar. Diariamente, utilizamos el lenguaje para todo tipo de cometidos y la información que compartimos en un contexto determinado puede ser crítica para la toma de decisiones por parte de una empresa.En los últimos años, han surgido multitud de herramientas para procesar el lenguaje natural y minar texto que, junto también con el auge de los frameworks de Aprendizaje Automático, han permitido el desarrollo de sistemas reales y precisos para tareas tan interesantes como el Análisis de Opinión y Sentimiento, Sistemas de Recomendación, Sistemas de Extracción Automática de Información, Análisis Semántico, Detección de Spam, Asistentes Virtuales como Siri, etc etcEn esta charla, repasaremos brevemente en que consiste el Procesamiento de Lenguaje Natural y la Minería de Texto, que aplicaciones tienen estos campos y algunos casos de éxito relacionados. Posteriormente,  haremos un repaso a algunas de las herramientas que ofrece el ecosistema de Python para estas tareas, entre ellas: * La mítica libreria *NLTK* (http://www.nltk.org/)* *TextBlob* (https://textblob.readthedocs.org/en/dev/)* *GenSim* (https://radimrehurek.com/gensim/)* *CliPs Pattern* (http://www.clips.ua.ac.be/pattern)Veremos también como estas disciplinas están hoy en día íntimamente relacionadas con las técnicas de Machine Learning. Como caso de uso para demostrar la utilidad de todas estas herramientas, intentaremos resolver un reto publicado en Kraggle para la detección de insultos o trolling en comentarios en redes sociales: https://www.kaggle.com/c/detecting-insults-in-social-commentary</abstract><persons><person>Rafa Haro</person></persons></event><event id="53"><date>2015-11-22T12:30:00+0100</date><start>12:30</start><duration>00:40</duration><room>1G-0.6 (Científico)</room><title>Tratando datos más allá de los límites de la memoria</title><description>En la era del 'Big Data' se necesitan cantidades cada vez más grandes de memoria (RAM) para tratar y analizar estos datos.  Pero tarde o temprano se llega a unos límites por encima de los cuales no se puede (o es muy caro) pasar.El compresor Blosc (blosc.org) y el contenedor de datos bcolz (bcolz.blosc.org), usan las capacidades de los ordenadores modernos (caches, procesadores multihilo y SSDs) para permitir tratar datos más allá los límites de la memoria.</description><abstract /><persons><person>Francesc Alted</person></persons></event><event id="57"><date>2015-11-22T13:10:00+0100</date><start>13:10</start><duration>00:40</duration><room>1G-0.6 (Científico)</room><title>Dive into Scrapy</title><description>Scrapy is a fast high-level screen scraping and web crawling framework, used to crawl websites and extract structured data from their pages. It can be used for a wide range of purposes, from data mining to monitoring and automated testing.In this talk some advanced techniques will be shown based on how Scrapy is used at Scrapinghub.</description><abstract>Scrapy is a fast high-level screen scraping and web crawling framework, used to crawl websites and extract structured data from their pages. It can be used for a wide range of purposes, from data mining to monitoring and automated testing.In this talk some advanced techniques will be shown based on how Scrapy is used at Scrapinghub.Goals:- Understand why its necessary to Scrapy-ify early on.- Anatomy of a Scrapy Spider.- Using the interactive shell.- What are items and how to use item loaders.- Examples of pipelines and middlewares.- Techniques to avoid getting banned.- How to deploy Scrapy projects.</abstract><persons><person>Juan Riaza</person></persons></event><event id="61"><date>2015-11-22T15:00:00+0100</date><start>15:00</start><duration>00:40</duration><room>1G-0.6 (Científico)</room><title>Fiona y Shapely, la punta del iceberg del análisis de datos geográficos con Python</title><description>Fiona y Shapely son la puerta de entrada al análisis de datos geográficos con Python. En la charla haremos una introducción básica a su uso y realizaremos un pequeño mapa de dmostación.</description><abstract>Tras una beve introducción de conceptos cartográficos mínimos a tener en cuenta a la hora de trabajar con datos espaciales, revisaremos:* Uso de Fiona para cargar datos geográficos.* Uso de Shapely para realizar unas operaciones de análisis espacial básicas.* Representación de los resultados en un mapa.Geoinquietos Valencia es un grupo de entusiastas de las tecnologías geoespaciales.Esta charla la impartiremos Pedro-Juan Ferrer @vehrka y Jorge Sanz @xurxosanz El nivel de la charla seguramente sea muy básico para Pythonistas experimentados pero creemos que puede ser una buena introducción al tema de tratamiento de información geográfica.</abstract><persons><person>Geoinquietos Valencia</person></persons></event><event id="64"><date>2015-11-22T15:40:00+0100</date><start>15:40</start><duration>00:40</duration><room>1G-0.6 (Científico)</room><title>Agujeros negros y optimización de código en python</title><description>En esta charla atenderemos a la construcción de un raytracer relativista en Python. Nuestro objetivo será conseguir imágenes similares a las observadas en la película Interestellar, mediante la creación de imágenes sintéticas en un entorno de gravedad extrema, como es un agujero negro. Utilizando esto como excusa, analizaremos distintos enfoques para optimizar nuestro código al máximo y conseguir programas eficientes y profesionales a la altura de cualquier otro lenguaje de programación.</description><abstract>Agujeros negros y optimización de código en python==================================================Descripción de la charla------------------------Como mucha gente ha dicho ya, Python no es en si mismo un lenguaje de programación científico, pero es el "pegamento" perfecto para unir código en otros lenguajes más enfocados con el objetivo de obtener lo mejor de cada mundo. Por otro lado, la versatilidad y flexibilidad de Python nos ofrece en conjunción con la clara sintaxis una de las herramientas más poderosas para crear código legible, de fácil mantenimiento, y de rápido desarrollo. En base a esto, continuamente se están desarrollando alternativas para poder desarrollar código científico basado en los estándares del HPC (High Performance Computing) utilizando herramientas inmanentemente relacionadas con Python. Con el objetivo de ilustrar cuales son estas herramientas, así como sus principales ventajas e inconvenientes, veremos como crear un raytracer relativista en Python. Los raytracer son programas que construyen imágenes sintéticas mediante el trazado de rayos desde una cámara hasta los objetos que queremos observar. En un entorno de gravedad extrema (como es un agujero negro) esto se vuelve especialmente difícil puesto que los rayos ya nos siguen trayectorias rectas y los efectos relativistas son muy importantes. De esta forma, comenzaremos comprendiendo un modelo muy sencillo de raytracer para después plantearnos sucesivas mejoras al código hasta llegar a rendimientos muy elevados, que satisfacen los estándares más exigentes del HPC.Principales módulos de optimización que usaremos-----------------------------------------------Los principales módulos que utilizaremos para optimizar nuestro código y que analizaremos brevemente son:*   Numpy.*   Numba.*   Mpi4py.*   pyCuda</abstract><persons><person>Pablo Galindo Salgado</person></persons></event></room><room name="1G-0.4 (Básico)"><event id="41"><date>2015-11-22T09:20:00+0100</date><start>09:20</start><duration>00:40</duration><room>1G-0.4 (Básico)</room><title>Implantación de ElasticSearch: problemas y soluciones</title><description>En esta charla se presentará de manera resumida un caso real: el proceso de implantación de ElasticSearch en una aplicación de Django. Partiendo de la motivación de implementar un buscador, veremos los problemas encontrados por nuestro equipo (¡y sus soluciones!). A saber: instalación, definición de los documentos, modo de conexión, indexado, particionado y sincronía con nuestra base de datos.</description><abstract>La charla explicará un caso de uso real: la implantación de ElasticSearch en nuestra herramienta de análisis. Ante la necesidad de implementar un buscador full-text, el equipo de Acceso nos decantamos por ElasticSearch sin tener experiencia previa con dicha tecnología. Conforme el proyecto fue avanzando nos encontramos distintas dudas o problemas:* ¿Cómo lo instalamos? ¿Y dónde?* ¿Cómo definimos los documentos? ¿Y cómo los indexamos?* ¿Nos conectamos desde el servidor, o será el propio cliente el que se encargue?* ¿Cómo representamos la jerarquía de nuestro modelo de datos?* ¿Deberíamos particionar los índices para ganar eficiencia?* ¿Cuál es el mejor modo de resolver problemas de sincronización?Recorriendo cronológicamente nuestra *aventura* con ElasticSearch, la charla tendrá un enfoque teórico pero desde el punto de vista de  un caso práctico, que podrá ser de utilidad para cualquier desarrollador (o equipo de desarrollo) que quiera implementar este motor de búsqueda.</abstract><persons><person>Miguel Sánchez Rodríguez</person><person>Miguel González Nieto</person></persons></event><event id="43"><date>2015-11-22T10:00:00+0100</date><start>10:00</start><duration>00:40</duration><room>1G-0.4 (Básico)</room><title>Como crear un bot para Telegram</title><description>En esta charla veremos como es posible crear un bot para Telegram utilizando la libreria pyTelegramBotAPI y Telegram Bot API. Se mostraran los pasos a seguir para crear un bot sencillo que pueda aceptar interacción del usuario</description><abstract>El servicio de mensajería Telegram ha desarrollado la opción de incluir bots en las conversaciones. Estos bots nos dan la posibilidad de desarrollar desde servicios de notificaciones o avisos de errores, hasta minijuegos para nuestros móviles.Aprovecharemos la API que han desarrollado en Telegram para explicar como generar un bot y utilizaremos la librería pyTelegramBotAPI para implementar funciones más avanzadas en Python.Casos de uso------------------Al final de la presentación se mostrarán algunas de las implementaciones reales hoy en día en funcionamiento.</abstract><persons><person>Urtzi Odriozola Lizaso</person></persons></event><event id="47"><date>2015-11-22T10:40:00+0100</date><start>10:40</start><duration>00:40</duration><room>1G-0.4 (Básico)</room><title>Plone 5: el CMS del futuro, en el presente.</title><description>Plone es un gestor de documental y contenidos con más de 10 años de recorrido. Creado inicialmente como una "cara bonita" del Content Management Framework ha evolucionado hasta nuestros días para traer una experiencia de uso y funcionalidades del más alto nivel.Con las últimas modificaciones realizadas durante el desarrollo, está a punto de publicarse la versión 5 de este CMS, íntegramente escrito en Python, y que presentaremos en esta charla.</description><abstract>La nueva versión incluye grandes mejoras en las características que siempre han caracterizado a Plone, tales como gestión de nuevos tipos de objetos (noticias, eventos, páginas, etc) directamente desde la web, integración de un sistema de theming desde la web, desarrollo de front-end utilizando tecnologías de preprocesado de CSS (LESS). También se han mejorado las características de workflow y gestión de permisos e integra por primera vez en la instalación por defecto, la gestión de contenido multilingüe. Nuevas y excitantes características, y mejora de las existentes las que han guiado el desarrollo de la versión 5 de este CMS, que cuenta con desarrolladores por todo el mundo y cuenta con un avanzado sistema de Integración Continua para la ejecución de test.</abstract><persons><person>Mikel Larreategi</person></persons></event><event id="49"><date>2015-11-22T11:50:00+0100</date><start>11:50</start><duration>00:40</duration><room>1G-0.4 (Básico)</room><title>Funcional para trollear</title><description>Usar lo que nos ofrece python para volver scripts imperativos en funcionales* y trollear a los colegas*Ciertas restricciones aplican</description><abstract /><persons><person>Alejandro Brito Monedero</person></persons></event><event id="54"><date>2015-11-22T12:30:00+0100</date><start>12:30</start><duration>00:40</duration><room>1G-0.4 (Básico)</room><title>Having it All: Distributed services with Django, Boto, and SQS queues</title><description>How do you let untrained people in your company run sensitive processes on different remote servers? Processes that must run asynchronously and sequentially while accessing different common resources? And how do you do it quickly and make it robust? I will show how we used Django, SQS and Boto to create a distributed and decoupled solution that let users invoke services asynchronously, which is secure, scalable and ensures that processes using common resources ran in sequence.</description><abstract /><persons><person>Julio Vicente Trigo Guijarro</person></persons></event><event id="55"><date>2015-11-22T13:10:00+0100</date><start>13:10</start><duration>00:40</duration><room>1G-0.4 (Básico)</room><title>Introducción a los DSL (Domain Specific Languages) en Python</title><description>Los lenguajes específicos de dominio son lenguajes especializados, simplificados y limitados a la resolución de problemas de un dominio concreto. Usados correctamente mejoran la productividad de los desarrolladores, así como la comunicación con los usuarios o expertos de otros dominios, entre otras ventajas. En esta charla introductoria veremos qué son, para qué sirven, en qué casos usarlos y algunas librerías de Python que nos facilitarán crear nuestros propios lenguajes específicos de dominio.</description><abstract>A pesar de ser una tecnología desarrollada y estudiada desde hace mucho tiempo, el uso de los DSL se ha popularizado últimamente, en parte gracias a los progresos que han facilitado y simplificado su implementación a partir de la definición de una gramática determinada, y en parte también por el auge de los lenguajes dinámicos.Uno de las principales beneficios que puede aportar un DSL es el incremento en la productividad de los desarrolladores. Un ejemplo claro son las expresiones regulares —un DSL con todas las de la ley— que pueden, con una sola expresión, sustituir una enorme cantidad de líneas de código. Las expresiones regulares suelen tener fama de complicadas, en parte por tener una sintaxis extremadamente concisa, pero (casi) nadie se plantea a día de hoy escribir una función desde cero para encontrar, por ejemplo, matrículas de coche dentro de un texto. Otra gran ventaja que se suele citar, a menudo considerada incluso más beneficiosa que la anterior, es la facilidad que proporciona para mejorar la comunicación entre los desarrolladores y los usuarios o expertos de un dominio, al permitir la creación de un lenguaje común. Los DSL son una especie de *lingua franca* en la que expertos de ambos lados pueden expresar reglas de negocio, condiciones necesarias, garantías, comportamientos y características del sistema que son igualmente comprensibles para todos y están escritas en un mismo lenguaje.Algunos lenguajes, como Groovy, Scala o Ruby, se han ganado merecida fama de especialmente adecuados para implementar un DSL, pero Python no se queda atrás, como veremos en esta charla.</abstract><persons><person>Juan Ignacio Rodríguez de León</person></persons></event><event id="59"><date>2015-11-22T15:00:00+0100</date><start>15:00</start><duration>00:40</duration><room>1G-0.4 (Básico)</room><title>Life of a Python program</title><description>Sometimes is good to know what's happening under the hood, this talk will explain how CPython works internally since we type `python myprogram.py` until our code is finally executedexplaining the process that CPython does to run our programs.The goal of this talk is explain people how to explore the codeof the interpreter itself using some common tools and let regularPython developers that aren't used to work with C lose the fearabout looking under the hood.</description><abstract>Sometimes is good to know what's happening under the hood, this talk will explain how CPython works internally since we type `python myprogram.py` until our code is finally executedexplaining the process that CPython does to run our programs.The goal of this talk is explain people how to explore the codeof the interpreter itself using some common tools and let regularPython developers that aren't used to work with C lose the fearabout looking under the hood and with luck inspire some of themto contribute into CPython.</abstract><persons><person>Francisco Fernández Castaño</person></persons></event><event id="62"><date>2015-11-22T15:40:00+0100</date><start>15:40</start><duration>00:40</duration><room>1G-0.4 (Básico)</room><title>Python in the Sky</title><description>Case study of Immfly’s Wireless In-Flight Entertainment system, built using Python.</description><abstract /><persons><person>David Arcos</person></persons></event></room><room name="Hall"><event id="48"><date>2015-11-22T11:20:00+0100</date><start>11:20</start><duration>00:30</duration><room>Hall</room><title>Coffe Break</title></event><event id="58"><date>2015-11-22T13:50:00+0100</date><start>13:50</start><duration>01:10</duration><room>Hall</room><title>Comida</title></event><event id="65"><date>2015-11-22T16:20:00+0100</date><start>16:20</start><duration>00:30</duration><room>Hall</room><title>Coffe Break</title></event></room><room name="Aula 1" /><room name="Aula 2" /><room name="Aula 3" /></day></schedule>